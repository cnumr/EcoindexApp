# **************************
#  Release Electron app
#  Build and release on multiple OS (matrix) to generate installers
#  Triggered after PR merge to main with changesets
# **************************

name: Release Electron app

on:
    push:
        branches:
            - main
        # Ne se dÃ©clenche que si le commit contient "chore: version packages"
        # Cela Ã©vite de builder Ã  chaque merge, seulement aprÃ¨s la PR de version
    workflow_dispatch:

concurrency: ${{ github.workflow }}-${{ github.ref }}

jobs:
    check-release:
        runs-on: ubuntu-latest
        outputs:
            should-release: ${{ steps.check.outputs.should-release }}
            version: ${{ steps.check.outputs.version }}
        steps:
            - name: Checkout Repo
              uses: actions/checkout@v4
              with:
                  fetch-depth: 0

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version-file: '.nvmrc'

            - name: Install dependencies
              run: npm ci

            - name: Check if version changed (should release)
              id: check
              run: |
                  # VÃ©rifier si le dernier commit contient "chore: version packages" (crÃ©Ã© par changeset)
                  # Ce commit est crÃ©Ã© par le workflow changeset.yml aprÃ¨s le merge de la PR de version
                  LAST_COMMIT=$(git log -1 --pretty=%B)
                  if echo "$LAST_COMMIT" | grep -q "chore: version packages"; then
                    VERSION=$(node -e "const fs = require('fs'); const pkg = JSON.parse(fs.readFileSync('package.json', 'utf8')); console.log(pkg.version);")
                    echo "should-release=true" >> $GITHUB_OUTPUT
                    echo "version=$VERSION" >> $GITHUB_OUTPUT
                    echo "âœ… Version dÃ©tectÃ©e: $VERSION - Le build va Ãªtre dÃ©clenchÃ©"
                  else
                    echo "should-release=false" >> $GITHUB_OUTPUT
                    echo "version=" >> $GITHUB_OUTPUT
                    echo "â­ï¸  Pas de version Ã  publier (commit: $LAST_COMMIT)"
                    echo "â­ï¸  Le workflow changeset.yml doit d'abord crÃ©er et merger une PR de version"
                  fi

    build:
        needs: check-release
        if: needs.check-release.outputs.should-release == 'true'
        strategy:
            fail-fast: false
            matrix:
                os:
                    - { name: 'linux', image: 'ubuntu-latest' }
                    - { name: 'windows', image: 'windows-latest' }
                    - { name: 'macos-intel', image: 'macos-15-intel' }
                    - { name: 'macos-arm', image: 'macos-15' }
        runs-on: ${{ matrix.os.image }}
        steps:
            - name: Checkout Repo
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version-file: '.nvmrc'

            - name: Setup Python (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              uses: actions/setup-python@v5
              with:
                  python-version: '3.12'

            - name: Cache node modules
              uses: actions/cache@v4
              with:
                  path: node_modules
                  key: ${{ runner.os }}-modules-${{ hashFiles('package-lock.json') }}
                  restore-keys: |
                      ${{ runner.os }}-modules-

            - name: Install dependencies
              run: npm ci
              env:
                  PUPPETEER_SKIP_DOWNLOAD: true

            - name: Debug APPLE_ID (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: echo ${APPLE_ID:0:3}
              env:
                  APPLE_ID: ${{ secrets.APPLE_ID }}

            - name: Debug APPLE_APP_SPECIFIC_PASSWORD (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: echo ${APPLE_APP_SPECIFIC_PASSWORD:0:3}
              env:
                  APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}

            - name: Debug APPLE_TEAM_ID (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: echo ${APPLE_TEAM_ID:0:3}
              env:
                  APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

            - name: Add macOS certificates (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  if [ -f "add-osx-cert.sh" ] && [ -n "$CERTIFICATE_OSX_APPLICATION" ] && [ -n "$CERTIFICATE_PASSWORD" ]; then
                    chmod +x add-osx-cert.sh && ./add-osx-cert.sh
                    echo "âœ… Certificats macOS installÃ©s"
                    
                    # VÃ©rifier que le certificat est bien installÃ©
                    echo "VÃ©rification des certificats installÃ©s..."
                    security find-identity -v -p codesigning | grep "Developer ID" || echo "âš ï¸  Aucun certificat Developer ID trouvÃ©"
                  else
                    echo "âŒ ERREUR: Certificats macOS non configurÃ©s"
                    echo "Les secrets suivants doivent Ãªtre configurÃ©s dans GitHub:"
                    echo "  - APPLE_APPLICATION_CERT"
                    echo "  - APPLE_APPLICATION_CERT_PASSWORD"
                    echo "  - APPLE_IDENTITY"
                    echo "  - APPLE_ID"
                    echo "  - APPLE_APP_SPECIFIC_PASSWORD"
                    echo "  - APPLE_TEAM_ID"
                    exit 1
                  fi
              env:
                  CERTIFICATE_OSX_APPLICATION: ${{ secrets.APPLE_APPLICATION_CERT }}
                  CERTIFICATE_PASSWORD: ${{ secrets.APPLE_APPLICATION_CERT_PASSWORD }}

            - name: Verify signing configuration (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  if [ -z "$APPLE_IDENTITY" ] || [ -z "$APPLE_ID" ] || [ -z "$APPLE_APP_SPECIFIC_PASSWORD" ] || [ -z "$APPLE_TEAM_ID" ]; then
                    echo "âŒ ERREUR: Configuration de signature macOS incomplÃ¨te"
                    echo "Les secrets suivants doivent Ãªtre configurÃ©s:"
                    echo "  - APPLE_IDENTITY: ${APPLE_IDENTITY:+âœ… dÃ©fini}${APPLE_IDENTITY:-âŒ manquant}"
                    echo "  - APPLE_ID: ${APPLE_ID:+âœ… dÃ©fini}${APPLE_ID:-âŒ manquant}"
                    echo "  - APPLE_APP_SPECIFIC_PASSWORD: ${APPLE_APP_SPECIFIC_PASSWORD:+âœ… dÃ©fini}${APPLE_APP_SPECIFIC_PASSWORD:-âŒ manquant}"
                    echo "  - APPLE_TEAM_ID: ${APPLE_TEAM_ID:+âœ… dÃ©fini}${APPLE_TEAM_ID:-âŒ manquant}"
                    exit 1
                  fi
                  echo "âœ… Configuration de signature macOS complÃ¨te"
                  echo "APPLE_IDENTITY complet: $APPLE_IDENTITY"
                  echo "APPLE_TEAM_ID: $APPLE_TEAM_ID"

                  # VÃ©rifier que le certificat correspond exactement
                  echo "Recherche du certificat correspondant..."
                  CERT_FOUND=$(security find-identity -v -p codesigning | grep "$APPLE_IDENTITY" || echo "")
                  if [ -z "$CERT_FOUND" ]; then
                    echo "âš ï¸  ATTENTION: Le certificat '$APPLE_IDENTITY' n'a pas Ã©tÃ© trouvÃ© exactement"
                    echo "Certificats disponibles:"
                    security find-identity -v -p codesigning | grep "Developer ID"
                    echo ""
                    echo "VÃ©rifiez que APPLE_IDENTITY correspond EXACTEMENT au nom du certificat ci-dessus"
                  else
                    echo "âœ… Certificat trouvÃ©: $CERT_FOUND"
                  fi
              env:
                  APPLE_IDENTITY: ${{ secrets.APPLE_IDENTITY }}
                  APPLE_ID: ${{ secrets.APPLE_ID }}
                  APPLE_APP_SPECIFIC_PASSWORD: ${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}
                  APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}

            - name: Set macOS environment variables
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  echo "APPLE_IDENTITY=${{ secrets.APPLE_IDENTITY }}" >> $GITHUB_ENV
                  echo "APPLE_ID=${{ secrets.APPLE_ID }}" >> $GITHUB_ENV
                  echo "APPLE_APP_SPECIFIC_PASSWORD=${{ secrets.APPLE_APP_SPECIFIC_PASSWORD }}" >> $GITHUB_ENV
                  echo "APPLE_TEAM_ID=${{ secrets.APPLE_TEAM_ID }}" >> $GITHUB_ENV
                  echo "DEBUG=@electron/osx-sign,electron-forge:*" >> $GITHUB_ENV

            - name: Build application
              shell: bash
              run: |
                  # VÃ©rifications macOS uniquement
                  if [ "${{ matrix.os.name }}" == "macos-intel" ] || [ "${{ matrix.os.name }}" == "macos-arm" ]; then
                    # VÃ©rifier que les variables d'environnement sont bien dÃ©finies
                    echo "VÃ©rification des variables de signature..."
                    echo "APPLE_IDENTITY complet: $APPLE_IDENTITY"
                    echo "APPLE_ID: ${APPLE_ID:0:10}..."
                    echo "APPLE_TEAM_ID: $APPLE_TEAM_ID"
                    echo "APPLE_APP_SPECIFIC_PASSWORD: ${APPLE_APP_SPECIFIC_PASSWORD:+âœ… dÃ©fini}"
                    
                    # VÃ©rifier que APPLE_IDENTITY contient "Developer ID"
                    if [ -n "$APPLE_IDENTITY" ]; then
                      if echo "$APPLE_IDENTITY" | grep -q "Developer ID"; then
                        echo "âœ… APPLE_IDENTITY contient 'Developer ID'"
                      else
                        echo "âŒ ERREUR: APPLE_IDENTITY ne contient pas 'Developer ID'"
                        echo "  Valeur: $APPLE_IDENTITY"
                        echo "  Cela empÃªchera hasSigningConfig d'Ãªtre true dans forge.config.js"
                      fi
                    else
                      echo "âŒ ERREUR: APPLE_IDENTITY n'est pas dÃ©fini"
                    fi
                    
                    # VÃ©rifier que le certificat est accessible dans le keychain par dÃ©faut
                    echo "Recherche du certificat dans le keychain..."
                    security find-identity -v -p codesigning
                    
                    # VÃ©rifier spÃ©cifiquement le certificat recherchÃ©
                    if [ -n "$APPLE_IDENTITY" ]; then
                      echo "Recherche du certificat exact: $APPLE_IDENTITY"
                      CERT_MATCH=$(security find-identity -v -p codesigning | grep -i "$APPLE_IDENTITY" || echo "")
                      if [ -z "$CERT_MATCH" ]; then
                        echo "âš ï¸  ATTENTION: Le certificat '$APPLE_IDENTITY' n'a pas Ã©tÃ© trouvÃ© exactement"
                        echo "Certificats Developer ID disponibles:"
                        security find-identity -v -p codesigning | grep "Developer ID"
                      else
                        echo "âœ… Certificat trouvÃ©: $CERT_MATCH"
                      fi
                    fi
                  fi

                  echo ""
                  echo "ðŸ” Variables d'environnement avant npm run make:"
                  echo "  APPLE_IDENTITY: ${APPLE_IDENTITY:+âœ… dÃ©fini}${APPLE_IDENTITY:-âŒ non dÃ©fini}"
                  if [ -n "$APPLE_IDENTITY" ]; then
                    echo "  APPLE_IDENTITY contient 'Developer ID': $(echo "$APPLE_IDENTITY" | grep -q "Developer ID" && echo "âœ… oui" || echo "âŒ non")"
                  fi

                  npm run make

            - name: Verify code signature (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  echo "VÃ©rification de la signature de l'application..."
                  # Trouver l'application dans le rÃ©pertoire de build
                  # Electron Forge place les apps dans out/make/zip/darwin/{arch}/
                  # Chercher dans tous les rÃ©pertoires d'architecture possibles
                  APP_PATH=""
                  TEMP_EXTRACT=""

                  # Chercher dans tous les rÃ©pertoires d'architecture
                  for ARCH_DIR in arm64 x64; do
                    ZIP_DIR="out/make/zip/darwin/${ARCH_DIR}"
                    if [ -d "$ZIP_DIR" ]; then
                      ZIP_FILE=$(find "$ZIP_DIR" -name "*.zip" -type f | head -1)
                      if [ -n "$ZIP_FILE" ]; then
                        echo "Extraction temporaire du ZIP pour vÃ©rification..."
                        TEMP_EXTRACT=$(mktemp -d)
                        ditto -xk "$ZIP_FILE" "$TEMP_EXTRACT"
                        APP_PATH=$(find "$TEMP_EXTRACT" -name "*.app" -type d | head -1)
                        if [ -n "$APP_PATH" ]; then
                          break
                        fi
                      fi
                    fi
                  done

                  # Si pas trouvÃ© dans le ZIP, chercher directement
                  if [ -z "$APP_PATH" ]; then
                    APP_PATH=$(find out/make -name "*.app" -type d | head -1)
                  fi

                  if [ -z "$APP_PATH" ]; then
                    echo "âŒ Aucune application .app trouvÃ©e"
                    echo "Contenu de out/make:"
                    ls -la out/make/ || true
                    echo "Contenu de out/make/zip/darwin:"
                    ls -la out/make/zip/darwin/ || true
                    exit 1
                  fi
                  echo "Application trouvÃ©e: $APP_PATH"

                  # VÃ©rifier la signature (codesign retourne toujours un code de sortie, donc on capture la sortie)
                  SIGNATURE_OUTPUT=$(codesign -dv --verbose=4 "$APP_PATH" 2>&1)
                  SIGNATURE_EXIT=$?
                  echo "$SIGNATURE_OUTPUT"

                  # VÃ©rifier si la signature est "adhoc" (non signÃ©e) ou valide
                  if echo "$SIGNATURE_OUTPUT" | grep -q "Signature=adhoc"; then
                    echo "âŒ ERREUR: L'application n'est pas signÃ©e (signature adhoc)"
                    echo "VÃ©rifiez que hasSigningConfig est true dans forge.config.js"
                    echo ""
                    echo "Debug: Variables d'environnement au moment du build:"
                    echo "  APPLE_IDENTITY Ã©tait dÃ©fini: ${APPLE_IDENTITY:+oui}${APPLE_IDENTITY:-non}"
                    echo ""
                    echo "VÃ©rifiez les logs du step 'Build application' pour voir si hasSigningConfig Ã©tait true"
                    exit 1
                  elif echo "$SIGNATURE_OUTPUT" | grep -q "Signature=" && ! echo "$SIGNATURE_OUTPUT" | grep -q "Signature=adhoc"; then
                    echo "âœ… Signature vÃ©rifiÃ©e (non-adhoc)"
                  elif [ $SIGNATURE_EXIT -eq 0 ]; then
                    echo "âœ… Signature vÃ©rifiÃ©e (code de sortie: 0)"
                  else
                    echo "âš ï¸  Avertissement: Impossible de vÃ©rifier la signature (code: $SIGNATURE_EXIT)"
                    echo "Sortie complÃ¨te:"
                    echo "$SIGNATURE_OUTPUT"
                  fi

                  # VÃ©rifier la notarisation (peut prendre quelques minutes aprÃ¨s la notarisation)
                  if spctl --assess --verbose --type execute "$APP_PATH" 2>&1; then
                    echo "âœ… Notarisation vÃ©rifiÃ©e"
                  else
                    echo "âš ï¸  Avertissement: La notarisation n'est pas vÃ©rifiÃ©e (peut prendre quelques minutes aprÃ¨s la notarisation)"
                  fi

                  # Afficher les dÃ©tails de la signature
                  codesign -dvv "$APP_PATH" 2>&1 | head -20

                  # Nettoyer l'extraction temporaire
                  if [ -n "$TEMP_EXTRACT" ] && [ -d "$TEMP_EXTRACT" ]; then
                    rm -rf "$TEMP_EXTRACT"
                  fi

            - name: Create DMG (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  node scripts/create-dmg.js

            - name: Verify DMG signature (macOS only)
              if: matrix.os.name == 'macos-intel' || matrix.os.name == 'macos-arm'
              run: |
                  echo "VÃ©rification de la signature dans le DMG..."
                  # Trouver le DMG crÃ©Ã©
                  DMG_PATH=$(find out/make -name "*.dmg" -type f | head -1)
                  if [ -z "$DMG_PATH" ]; then
                    echo "âš ï¸  Aucun DMG trouvÃ©"
                    exit 0
                  fi
                  echo "DMG trouvÃ©: $DMG_PATH"

                  # Monter le DMG temporairement pour vÃ©rifier
                  MOUNT_POINT=$(mktemp -d)
                  hdiutil attach "$DMG_PATH" -mountpoint "$MOUNT_POINT" -quiet

                  APP_IN_DMG=$(find "$MOUNT_POINT" -name "*.app" -type d | head -1)
                  if [ -n "$APP_IN_DMG" ]; then
                    echo "VÃ©rification de la signature de l'application dans le DMG..."
                    if codesign -dv --verbose=4 "$APP_IN_DMG" 2>&1; then
                      echo "âœ… Signature vÃ©rifiÃ©e dans le DMG"
                    else
                      echo "âŒ ERREUR: La signature n'est pas valide dans le DMG"
                      hdiutil detach "$MOUNT_POINT" -quiet
                      exit 1
                    fi
                  fi

                  hdiutil detach "$MOUNT_POINT" -quiet

            - name: Upload artifacts
              uses: actions/upload-artifact@v4
              with:
                  name: ${{ matrix.os.name }}-artifacts
                  path: |
                      out/**/*.deb
                      out/**/*.dmg
                      out/**/*setup.exe
                      out/**/*.rpm
                      out/**/*.zip
                  retention-days: 7

    release:
        needs: [check-release, build]
        if: needs.check-release.outputs.should-release == 'true'
        runs-on: ubuntu-latest
        permissions:
            contents: write
        steps:
            - name: Checkout Repo
              uses: actions/checkout@v4

            - name: Setup Node.js
              uses: actions/setup-node@v4
              with:
                  node-version-file: '.nvmrc'

            - name: Install dependencies
              run: npm ci

            - name: Download all artifacts
              uses: actions/download-artifact@v4
              with:
                  path: artifacts

            - name: Remove duplicate files
              run: |
                  echo "Recherche des fichiers en double..."
                  # CrÃ©er un dossier temporaire pour les fichiers uniques
                  mkdir -p artifacts-unique
                  
                  # Trouver tous les fichiers et les copier dans artifacts-unique en Ã©vitant les doublons
                  # Utiliser le nom de fichier comme clÃ© unique
                  find artifacts -type f \( -name "*.deb" -o -name "*.dmg" -o -name "*.exe" -o -name "*.rpm" -o -name "*.zip" \) | while read file; do
                    filename=$(basename "$file")
                    if [ ! -f "artifacts-unique/$filename" ]; then
                      echo "Copie de $file vers artifacts-unique/$filename"
                      cp "$file" "artifacts-unique/$filename"
                    else
                      echo "Fichier $filename dÃ©jÃ  copiÃ©, ignorÃ©: $file"
                    fi
                  done
                  
                  # Remplacer artifacts par artifacts-unique
                  rm -rf artifacts
                  mv artifacts-unique artifacts
                  
                  echo "Fichiers uniques dans artifacts:"
                  find artifacts -type f | sort

            - name: Generate Release.txt
              run: echo ${{ github.sha }} > Release.txt

            - name: Create GitHub Release
              uses: softprops/action-gh-release@v2
              with:
                  name: Release Electron-app ${{ needs.check-release.outputs.version }}
                  tag_name: ${{ needs.check-release.outputs.version }}
                  files: |
                      Release.txt
                      artifacts/**/*.deb
                      artifacts/**/*.dmg
                      artifacts/**/*setup.exe
                      artifacts/**/*.rpm
                      artifacts/**/*.zip
                  generate_release_notes: true
                  fail_on_unmatched_files: false
                  overwrite_files: false
              env:
                  GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

            - name: Publish to npm (if configured)
              if: env.NPM_TOKEN != ''
              run: npm publish
              env:
                  NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
